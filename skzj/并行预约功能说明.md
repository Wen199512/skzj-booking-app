# ?? 并行预约功能实现说明

## ?? 需求

当选择多个活动时，多个活动**同时进行预约**，而不是预约完一个再预约一个。

---

## ? 已完成的修改

### 修改文件
- `MainPage.xaml.cs`

### 修改内容

#### 1. 修改 `RunBookingAsync` 方法

**之前（串行预约）**：
```csharp
// 依次预约每个活动
foreach (var activity in _selectedActivities)
{
    if (cancellationToken.IsCancellationRequested)
        break;

    Log($"\n--- 预约活动: {activity.ActTitle} (ID: {activity.ActId}) ---");

    var results = await _bookingService.RunBookingAsync(
        activity.ActId,
        accounts,
        cancellationToken,
        msg => Log(msg),
        () => Interlocked.Increment(ref _totalSubmits)
    );

    // 等待一个活动预约完成后，再预约下一个
    await Task.Delay(1000, cancellationToken);
}
```

**现在（并行预约）**：
```csharp
// 并行预约所有选中的活动
var bookingTasks = _selectedActivities.Select(activity => 
    BookActivityAsync(activity, accounts, cancellationToken)
).ToList();

// 等待所有预约任务完成
var allResults = await Task.WhenAll(bookingTasks);
```

#### 2. 新增 `BookActivityAsync` 方法

```csharp
/// <summary>
/// 预约单个活动
/// </summary>
private async Task<List<string>> BookActivityAsync(
    ActivityInfo activity, 
    List<Account> accounts, 
    CancellationToken cancellationToken)
{
    try
    {
        Log($"\n[{activity.ActTitle}] 开始预约 (ID: {activity.ActId})");

        var results = await _bookingService.RunBookingAsync(
            activity.ActId,
            accounts,
            cancellationToken,
            msg => Log($"[{activity.ActTitle}] {msg}"),
            () => Interlocked.Increment(ref _totalSubmits)
        );

        var formattedResults = results
            .Select(r => $"[{activity.ActTitle}] {r}")
            .ToList();

        Log($"[{activity.ActTitle}] 预约完成");
        
        return formattedResults;
    }
    catch (OperationCanceledException)
    {
        Log($"[{activity.ActTitle}] 预约已取消");
        return new List<string> { $"[{activity.ActTitle}] 预约已取消" };
    }
    catch (Exception ex)
    {
        Log($"[{activity.ActTitle}] 预约失败: {ex.Message}");
        return new List<string> { $"[{activity.ActTitle}] 预约失败: {ex.Message}" };
    }
}
```

---

## ?? 功能对比

### 之前：串行预约（Sequential）

```
开始预约
   ↓
预约活动 A
   ↓ (等待 A 完成)
预约活动 B
   ↓ (等待 B 完成)
预约活动 C
   ↓ (等待 C 完成)
全部完成

总时间 = 时间A + 时间B + 时间C
```

### 现在：并行预约（Parallel）

```
开始预约
   ↓
   ├─ 预约活动 A
   ├─ 预约活动 B (同时进行)
   └─ 预约活动 C (同时进行)
   ↓
全部完成

总时间 = max(时间A, 时间B, 时间C)
```

---

## ?? 性能提升

### 假设每个活动预约需要 10 秒

| 场景 | 之前（串行） | 现在（并行） | 提升 |
|------|------------|------------|------|
| **1 个活动** | 10 秒 | 10 秒 | - |
| **2 个活动** | 20 秒 | 10 秒 | **50%** ?? |
| **3 个活动** | 30 秒 | 10 秒 | **67%** ?? |

---

## ?? 用户体验改进

### 之前的流程

```
选择活动：
  ? 活动 A
  ? 活动 B
  ? 活动 C

点击"开始预约" ↓

日志输出：
[10:00:00] 开始预约 3 个活动...
[10:00:00] --- 预约活动: 活动 A (ID: 123) ---
[10:00:05] [活动 A] 预约成功
[10:00:05] --- 预约活动: 活动 B (ID: 456) ---
[10:00:10] [活动 B] 预约成功
[10:00:10] --- 预约活动: 活动 C (ID: 789) ---
[10:00:15] [活动 C] 预约成功
[10:00:15] 所有活动预约完成

总耗时：15 秒 ? 太慢
```

### 现在的流程

```
选择活动：
  ? 活动 A
  ? 活动 B
  ? 活动 C

点击"开始预约" ↓

日志输出：
[10:00:00] 开始并行预约 3 个活动...
[10:00:00] [活动 A] 开始预约 (ID: 123)
[10:00:00] [活动 B] 开始预约 (ID: 456)
[10:00:00] [活动 C] 开始预约 (ID: 789)
[10:00:05] [活动 A] 预约成功
[10:00:05] [活动 B] 预约成功
[10:00:05] [活动 C] 预约成功
[10:00:05] 所有活动预约完成

总耗时：5 秒 ? 快 3 倍！
```

---

## ?? 技术实现细节

### 1. 使用 LINQ Select 创建任务列表

```csharp
var bookingTasks = _selectedActivities.Select(activity => 
    BookActivityAsync(activity, accounts, cancellationToken)
).ToList();
```

**说明**：
- 为每个选中的活动创建一个异步任务
- 所有任务立即开始执行（并行）

### 2. 使用 Task.WhenAll 等待所有任务

```csharp
var allResults = await Task.WhenAll(bookingTasks);
```

**说明**：
- 等待所有预约任务完成
- 如果任一任务失败，会抛出异常
- 返回所有任务的结果

### 3. 日志输出带活动名称

```csharp
msg => Log($"[{activity.ActTitle}] {msg}")
```

**说明**：
- 每条日志都带有活动名称前缀
- 方便区分哪条日志属于哪个活动
- 并行预约时日志会交错显示

### 4. 线程安全的计数器

```csharp
() => Interlocked.Increment(ref _totalSubmits)
```

**说明**：
- 使用 `Interlocked.Increment` 确保线程安全
- 多个任务同时增加计数时不会冲突

---

## ?? 测试场景

### 场景 1: 预约单个活动

**操作**：
1. 选择 1 个活动
2. 点击"开始预约"

**预期**：
- 行为与之前相同
- 只预约一个活动

### 场景 2: 预约多个活动（并行）

**操作**：
1. 选择 3 个活动
2. 点击"开始预约"

**预期**：
```
[10:00:00] 开始并行预约 3 个活动...
[10:00:00] [活动 A] 开始预约
[10:00:00] [活动 B] 开始预约
[10:00:00] [活动 C] 开始预约
[10:00:01] [活动 A] 正在提交...
[10:00:01] [活动 B] 正在提交...
[10:00:01] [活动 C] 正在提交...
...
[10:00:05] [活动 A] 预约完成
[10:00:05] [活动 B] 预约完成
[10:00:05] [活动 C] 预约完成
[10:00:05] 所有活动预约完成
```

### 场景 3: 取消并行预约

**操作**：
1. 选择 3 个活动
2. 点击"开始预约"
3. 立即点击"停止"

**预期**：
- 所有正在进行的预约任务都会收到取消信号
- 日志显示每个活动的取消状态

### 场景 4: 部分活动预约失败

**操作**：
1. 选择 3 个活动（其中一个可能失败）
2. 点击"开始预约"

**预期**：
- 成功的活动正常完成
- 失败的活动显示错误信息
- 其他活动不受影响（继续执行）

---

## ?? 注意事项

### 1. 服务器负载

**问题**：并行预约会同时向服务器发送多个请求

**解决**：
- 当前最多选择 3 个活动（`MaxSelectedActivities = 3`）
- 如果需要，可以增加限制或错开请求时间

### 2. 日志顺序

**问题**：并行执行时日志可能交错显示

**解决**：
- 每条日志都带有活动名称前缀 `[活动名称]`
- 使用 `lock (_logLock)` 确保日志输出线程安全

### 3. 错误处理

**问题**：一个活动失败不应影响其他活动

**解决**：
- 每个活动的预约都有独立的 `try-catch`
- 单个活动失败不会终止其他活动

---

## ?? 版本更新建议

### 是否需要更新版本号？

#### 选项 1: 保持 v1.0.5（推荐）

**理由**：
- 只是优化了预约逻辑
- 没有改变用户界面
- 功能行为一致（只是更快）

#### 选项 2: 更新到 v1.0.6

**理由**：
- 如果想明确标记这次性能优化
- 方便追踪哪个版本有并行预约功能

**如果更新版本号**：

修改 `skzj.csproj`：
```xml
<ApplicationDisplayVersion>1.0.6</ApplicationDisplayVersion>
<ApplicationVersion>7</ApplicationVersion>
```

创建 Release 说明：
```markdown
v1.0.6 - 性能优化
- ? 并行预约多个活动
- ? 预约速度提升最高 67%
- ? 减少等待时间
```

---

## ?? 代码变更总结

### 修改的方法

1. **`RunBookingAsync`**
   - 从串行 `foreach` 改为并行 `Task.WhenAll`
   - 移除活动间的延迟 `Task.Delay`
   - 简化日志输出逻辑

2. **新增 `BookActivityAsync`**
   - 独立的活动预约方法
   - 包含完整的错误处理
   - 返回格式化的结果列表

### 未修改的部分

- ? UI 界面
- ? 活动选择逻辑
- ? 最大选择数限制
- ? 取消功能
- ? 日志显示

---

## ?? 优势总结

### 1. 性能提升

- ? 预约速度提升 **50%-67%**
- ? 减少用户等待时间
- ? 更高效的网络资源利用

### 2. 用户体验

- ? 更快的预约完成
- ? 实时显示所有活动的进度
- ? 日志输出更清晰（带活动名称）

### 3. 代码质量

- ? 代码结构更清晰（单独的预约方法）
- ? 错误处理更完善
- ? 线程安全保证

### 4. 可扩展性

- ? 易于添加新功能（如优先级预约）
- ? 易于调整并发数
- ? 易于添加进度显示

---

## ?? 下一步

### 立即可用

修改已完成，可以立即：
1. **构建 APK**
2. **测试并行预约功能**
3. **发布新版本**（如果需要）

### 可选的后续优化

1. **添加进度条**
   - 显示整体预约进度
   - 显示每个活动的预约状态

2. **添加预约优先级**
   - 允许用户设置活动预约顺序
   - 重要活动优先预约

3. **添加重试机制**
   - 失败的活动自动重试
   - 可配置重试次数

4. **添加并发限制配置**
   - 允许用户设置最大并发数
   - 根据网络状况自动调整

---

**并行预约功能已实现完成！** ??

测试时注意观察：
- ? 所有活动是否同时开始
- ? 日志是否正确显示活动名称
- ? 预约速度是否明显提升
- ? 错误处理是否正常工作
